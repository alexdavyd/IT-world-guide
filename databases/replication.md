# Репликация
## Содержание
1. [Что такое Репликация?](#что-такое-репликация)
2. [Master-Slave](#master-slave-primary-replica)
3. [Main и StandIn](#main-и-stand-in-активный-и-пассивный-узлы)
   - [Получение данных из Main](#как-stand-in-получает-актуальные-данные-из-main)
   - [Синхронный и асинхронный режимы](#синхронный-или-асинхронный-режим-для-stand-in)

##  Что такое репликация

Репликация — это процесс синхронизации данных между несколькими серверами так, чтобы на каждом была копия одних и тех же данных. Основные цели:
- **Отказоустойчивость** — если основной сервер выходит из строя, реплика берёт на себя нагрузку.
- **Балансировка нагрузки** — чтение можно распределять между репликами.
- **Геораспределение** — приближение данных к пользователям.

Существует несколько моделей репликации, но самые популярные — **master-slave** и **master-master**. В вашем вопросе упомянуты master/slave и main/stand-in — это вариации одной и той же идеи.

### Master-Slave (Primary-Replica)

- **Master (Primary)** — основной узел, который принимает все операции записи (INSERT, UPDATE, DELETE). Он является источником истины.
- **Slave (Replica)** — один или несколько подчинённых узлов, которые получают изменения от мастера и применяют их к своей копии данных. Обычно slave обслуживают только запросы на чтение (SELECT).

**Как работает синхронизация:**
1. Каждое изменение данных на master записывается в журнал (binary log в MySQL, WAL в PostgreSQL).
2. Slave подключается к master и запрашивает изменения из журнала.
3. Slave воспроизводит эти изменения у себя, поддерживая актуальность данных.
4. Возможны два режима: **асинхронный** (master не ждёт подтверждения от slave) и **синхронный** (запись считается завершённой только после фиксации на одном или нескольких slave).

**Преимущества:**
- Простота реализации.
- Горизонтальное масштабирование чтения.
- Защита от сбоев (можно переключить запись на slave).

**Недостатки:**
- Задержка репликации (slave может отставать).
- Единая точка отказа для записи (если master упал, запись невозможна до переключения).

### Main и Stand-In (активный и пассивный узлы)

Термины **Main** и **Stand-In** (или Primary и Standby) часто используются в контексте отказоустойчивых конфигураций, особенно в системах с автоматическим переключением (failover). Это частный случай master-slave, где standby узел обычно не обслуживает запросы на чтение (хотя может, если настроено), а находится в «горячем» режиме ожидания.

#### Как Stand-In получает актуальные данные из Main?

Есть несколько способов, наиболее распространённые в современных СУБД:

**A. Физическая репликация (на уровне блоков)**
- Main постоянно записывает изменения в **журнал предзаписи (WAL — Write-Ahead Log)**. Это журнал, куда попадают все модификации данных до того, как они будут применены к файлам базы.
- Stand-In подключается к Main и непрерывно получает сегменты WAL (или поток изменений).
- Stand-In применяет (воспроизводит) эти изменения к своим файлам данных. В результате база на Stand-In остаётся точной физической копией Main.
- Примеры: PostgreSQL с режимом репликации (streaming replication), SQL Server Always On Availability Groups.

**B. Логическая репликация (на уровне записей)**
- Main декодирует изменения из WAL в логический формат (например, вставка строки с конкретными значениями) и отправляет подписчикам.
- Stand-In получает эти логические изменения и применяет их к своей базе. При этом структура таблиц может немного отличаться (например, можно реплицировать только подмножество таблиц).
- Примеры: PostgreSQL logical replication, MySQL Group Replication (в определённых режимах).

**C. Триггерная или основанная на запросах репликация** (устаревшая)
- Специальные программы (например, Tungsten Replicator) читают бинарный лог и выполняют запросы на реплике.

#### Синхронный или асинхронный режим для Stand-In?

- **Асинхронный:** Main фиксирует транзакцию и сразу отвечает клиенту, не дожидаясь применения на Stand-In. Это быстро, но при сбое Main часть данных может быть потеряна.
- **Синхронный:** Main ждёт подтверждения от Stand-In о том, что изменения записаны (хотя бы в журнал). Это обеспечивает нулевые потери данных (zero data loss), но увеличивает задержку записи.

В классической паре Main/Stand-In часто используют **синхронный режим** для гарантии, что после переключения не пропадёт ни одна транзакция. Однако это компромисс производительности.

**Процесс переключения (failover):**
- Если Main выходит из строя, администратор или специальный менеджер (например, Pacemaker, Patroni) повышает Stand-In до роли Main.
- Приложения перенаправляются на новый Main.
- После восстановления старого Main он может стать Stand-In и начать догонять изменения, которые произошли за время его отсутствия.
