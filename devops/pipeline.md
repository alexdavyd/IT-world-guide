# Пайплайн (Pipeline) в разработке ПО: подробное руководство

## Содержание
1. [Что такое пайплайн?](#что-такое-пайплайн)
2. [Пайплайн в контексте CI/CD](#пайплайн-в-контексте-cicd)
3. [Основные элементы пайплайна](#основные-элементы-пайплайна)
4. [Типы пайплайнов](#типы-пайплайнов)
5. [Проектирование пайплайна](#проектирование-пайплайна)
6. [Примеры пайплайнов](#примеры-пайплайнов)
   - [GitHub Actions (Node.js)](#github-actions-nodejs)
   - [GitLab CI (Python)](#gitlab-ci-python)
   - [Jenkins (Java)](#jenkins-java)
7. [Лучшие практики](#лучшие-практики)
8. [Мониторинг и отладка пайплайнов](#мониторинг-и-отладка-пайплайнов)
9. [Антипаттерны пайплайнов](#антипаттерны-пайплайнов)
10. [Связь с другими разделами](#связь-с-другими-разделами)
11. [Заключение](#заключение)

---

## Что такое пайплайн?

**Пайплайн (конвейер)** в разработке программного обеспечения — это автоматизированная последовательность шагов, которые код проходит от момента коммита до доставки пользователю (или до другого конечного состояния). Пайплайн обеспечивает стандартизацию, повторяемость и прозрачность процессов сборки, тестирования и развёртывания.

Пайплайны бывают разных видов:
- **CI/CD пайплайны** — для непрерывной интеграции и доставки (основной фокус этого документа).
- **Data pipelines** — для обработки и трансформации данных (ETL).
- **ML pipelines** — для обучения и развёртывания моделей машинного обучения.
- **Infrastructure pipelines** — для управления инфраструктурой как кодом (Terraform, CloudFormation).

В этом руководстве мы сосредоточимся на CI/CD пайплайнах, но многие концепции применимы и к другим типам.

---

## Пайплайн в контексте CI/CD

В CI/CD пайплайн — это реализация практик непрерывной интеграции, доставки и развёртывания. Он автоматизирует:

- Сборку приложения.
- Запуск тестов (модульных, интеграционных, приёмочных).
- Анализ кода (линтинг, статический анализ, проверка уязвимостей).
- Создание артефактов (Docker-образы, JAR-файлы, дистрибутивы).
- Развёртывание на различные окружения (staging, production).
- Уведомление команды о результатах.

Пайплайн описывается в коде (конфигурационные файлы) и хранится вместе с проектом, что обеспечивает версионирование и воспроизводимость.

---

## Основные элементы пайплайна

### 1. Триггеры (Triggers)
События, запускающие пайплайн:
- Push в определённую ветку.
- Создание pull request.
- По расписанию (ночные сборки).
- Вручную.

### 2. Стадии (Stages)
Логические блоки, выполняемые последовательно или параллельно. Каждая стадия может содержать несколько шагов. Пример стадий: `build`, `test`, `deploy`.

### 3. Шаги (Steps)
Конкретные команды или действия внутри стадии (например, `npm install`, `docker build`).

### 4. Артефакты (Artifacts)
Результаты работы пайплайна, которые сохраняются для дальнейшего использования (лог-файлы, отчёты о тестировании, собранные пакеты).

### 5. Окружения (Environments)
Целевые среды, куда выполняется развёртывание (development, staging, production).

### 6. Переменные и секреты (Variables & Secrets)
Параметры конфигурации, которые могут меняться между запусками (ключи API, пароли, настройки).

### 7. Уведомления (Notifications)
Оповещения о статусе пайплайна (Slack, email, Telegram).

---

## Типы пайплайнов

### По структуре выполнения

| Тип               | Описание                                                                 |
| ----------------- | ------------------------------------------------------------------------ |
| **Последовательный** | Стадии выполняются одна за другой. Простота, но медленнее.              |
| **Параллельный**     | Некоторые стадии (или шаги) выполняются одновременно (например, тесты на разных версиях). Ускоряет обратную связь. |
| **Смешанный**        | Комбинация последовательных и параллельных этапов.                       |
| **С условным ветвлением** | Некоторые шаги выполняются только при определённых условиях (например, деплой только для main-ветки). |
| **С ручным подтверждением** | Пайплайн останавливается на определённой стадии и ждёт ручного утверждения (характерно для Continuous Delivery). |

### По назначению

- **CI-пайплайн** — только сборка и тесты (до создания артефакта).
- **CD-пайплайн** — включает развёртывание на окружения (может быть доставкой или деплоем).
- **Full pipeline** — объединяет CI и CD в один непрерывный процесс.

---

## Проектирование пайплайна

### Шаг 1: Определите цели
Что должен делать пайплайн? Например:
- Гарантировать, что код собирается и тесты проходят.
- Автоматически разворачивать на staging после каждого коммита.
- Выкатывать в production по кнопке.

### Шаг 2: Разбейте процесс на стадии
Типовое разбиение:
1. **Setup** — установка зависимостей.
2. **Lint** — проверка стиля кода.
3. **Build** — компиляция, сборка.
4. **Test** — модульные и интеграционные тесты.
5. **Package** — создание артефакта.
6. **Deploy to Staging** — развёртывание на тестовое окружение.
7. **Acceptance Tests** — проверка на staging.
8. **Deploy to Production** (ручной или автоматический).

### Шаг 3: Определите зависимости между стадиями
Что должно выполниться перед чем? Например, тесты не могут запуститься без сборки.

### Шаг 4: Решите, какие шаги могут выполняться параллельно
Например, можно параллельно запускать тесты на разных версиях Node.js или Python.

### Шаг 5: Настройте уведомления
Кто и как должен узнавать о результатах?

### Шаг 6: Обеспечьте идемпотентность
Повторный запуск пайплайна должен давать тот же результат (если код не изменился).

---

## Примеры пайплайнов

### GitHub Actions (Node.js)

```yaml
name: Node.js CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [16, 18, 20]
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm ci
      - run: npm run lint
      - run: npm test
      - run: npm run build

  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Deploy to staging
        run: curl -X POST https://staging.example.com/deploy

  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://example.com
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Manual approval
        run: echo "Waiting for approval"
      - name: Deploy to production
        run: curl -X POST https://api.example.com/deploy/production
```

**Пояснения:**
- Параллельный запуск на трёх версиях Node.js.
- Стадия `deploy-staging` запускается только после успешного `build` и только для main-ветки.
- `deploy-production` требует ручного утверждения (благодаря `environment` с protection rules).

### GitLab CI (Python)

```yaml
stages:
  - lint
  - test
  - build
  - deploy

variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

cache:
  paths:
    - .cache/pip
    - .venv/

before_script:
  - python -m venv .venv
  - source .venv/bin/activate
  - pip install -r requirements.txt

lint:
  stage: lint
  script:
    - flake8 .

test:
  stage: test
  script:
    - pytest --cov=src tests/
  coverage: '/TOTAL.+?(\d+%)/'

build:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  only:
    - main

deploy-staging:
  stage: deploy
  script:
    - kubectl set image deployment/myapp myapp=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -n staging
    - kubectl rollout status deployment/myapp -n staging
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - main

deploy-production:
  stage: deploy
  script:
    - kubectl set image deployment/myapp myapp=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -n production
    - kubectl rollout status deployment/myapp -n production
  environment:
    name: production
    url: https://example.com
  when: manual
  only:
    - main
```

**Пояснения:**
- Чёткие стадии: lint, test, build, deploy.
- Кэширование зависимостей для ускорения.
- Ручной деплой на production (`when: manual`).

### Jenkins (Java) — Declarative Pipeline

```groovy
pipeline {
    agent any

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Build') {
            steps {
                sh 'mvn clean compile'
            }
        }

        stage('Test') {
            parallel {
                stage('Unit Tests') {
                    steps {
                        sh 'mvn test'
                    }
                }
                stage('Integration Tests') {
                    steps {
                        sh 'mvn verify -Pintegration-tests'
                    }
                }
            }
        }

        stage('Package') {
            steps {
                sh 'mvn package'
            }
            post {
                success {
                    archiveArtifacts 'target/*.jar'
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                branch 'main'
            }
            steps {
                sh './deploy.sh staging'
            }
        }

        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            input {
                message "Deploy to production?"
                ok "Yes"
            }
            steps {
                sh './deploy.sh production'
            }
        }
    }

    post {
        failure {
            emailext(
                to: 'team@example.com',
                subject: "Pipeline failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                body: "Check console output at ${env.BUILD_URL}"
            )
        }
    }
}
```

**Пояснения:**
- Параллельное выполнение unit и integration тестов.
- Артефакты сохраняются.
- Деплой на production с ручным подтверждением (`input`).

---

## Лучшие практики

1. **Держите пайплайн быстрым**  
   - Выносите медленные тесты в отдельные ночные сборки.
   - Параллелизируйте, где возможно.
   - Кэшируйте зависимости.

2. **Используйте идемпотентные шаги**  
   Повторный запуск не должен ломаться из-за состояния.

3. **Останавливайте пайплайн при первых ошибках (fail fast)**  
   Не тратьте время на продолжение, если одна стадия упала.

4. **Управляйте секретами безопасно**  
   - Не храните ключи в коде.
   - Используйте встроенные механизмы секретов (GitHub Secrets, GitLab CI Variables, HashiCorp Vault).

5. **Версионируйте артефакты**  
   Каждый артефакт должен быть уникально идентифицируем (тег коммита, номер сборки).

6. **Логируйте и сохраняйте отчёты**  
   Логи и результаты тестов должны быть доступны для анализа.

7. **Делайте пайплайн частью кода (Pipeline as Code)**  
   Храните конфигурацию в репозитории вместе с проектом.

8. **Тестируйте сам пайплайн**  
   Можно использовать локальный запуск (act для GitHub Actions, gitlab-runner exec для GitLab CI).

9. **Используйте чёткие имена стадий**  
   Названия должны отражать суть (build, test, deploy).

10. **Настраивайте уведомления только о действительно важных событиях**  
    Избегайте спама.

---

## Мониторинг и отладка пайплайнов

- **Визуализация:** Современные CI/CD-системы предоставляют графическое отображение пайплайна (стадии, успех/неудача).
- **Логи:** К каждому шагу прилагается вывод консоли — первый источник информации об ошибках.
- **Метрики:** Время выполнения стадий, частота успехов/неудач, тренды.
- **Интеграция с APM:** Можно отправлять данные о деплоях в системы мониторинга (Datadog, New Relic) для корреляции с инцидентами.
- **Отладка локально:** Некоторые инструменты позволяют запускать пайплайн локально (например, `act` для GitHub Actions, `gitlab-runner exec`).

---

## Антипаттерны пайплайнов

- **Слишком длинный пайплайн** (> 15–20 минут) — разработчики теряют фокус.
- **Нестабильные тесты (flaky)** — подрывают доверие к пайплайну.
- **Отсутствие кэширования** — каждый раз загружаются одни и те же зависимости.
- **Жёстко закодированные пути и учётные данные** — сложно переносить между окружениями.
- **Пайплайн, который падает, но команда не чинит** — теряется смысл автоматизации.
- **Одна стадия делает слишком много** — сложно понять, что именно сломалось.
- **Ручные действия в середине пайплайна** (кроме осознанного approval) — замедляют процесс.
- **Запуск всего пайплайна при любом изменении** — например, запуск интеграционных тестов на исправление опечатки в документации.

---

## Связь с другими разделами

- **[CI: непрерывная интеграция](ci.md)** — детали о CI-части пайплайна.
- **[CD: непрерывная доставка и развёртывание](cd.md)** — подробнее о стадиях доставки.
- **[Docker](docker.md)** — как контейнеры используются в пайплайнах.
- **[Kubernetes](kubernetes.md)** — целевая платформа для развёртывания.
- **[Тестирование](../tools/testing.md)** — виды тестов и их место в пайплайне.
- **[Безопасность](../glossary/security.md)** — безопасность пайплайна и секреты.
- **[Git](../devops/git/commands.md)** — триггеры на события в Git.

---

## Заключение

Пайплайн — это сердце современной разработки. Правильно спроектированный пайплайн ускоряет обратную связь, повышает качество кода и снижает риск релизов. Начинайте с простого пайплайна (сборка + тесты), затем постепенно добавляйте стадии развёртывания, параллелизацию и улучшайте его на основе обратной связи от команды. Помните: пайплайн — это код, и он требует такого же внимания, как и основной код проекта.

Используйте лучшие практики, избегайте антипаттернов, и ваш пайплайн станет надёжным помощником, а не источником проблем.